=== Enable cooperative cognition at arbitrary scale ===

1001. Define Intent Protocol
  1007. work out computational base layer concept
      done: true
  1010. bootstrap some initial type defintions
      done: true
  1034. add concepts of users and stream authority
  1140. add 'meta' boostrapped entity with 'names' under it
      done: true
1002. Implement Intent Runtime
  1035. make 'types' act like constraints on additional op submission
  1013. make the runtime support function definition and invocation
      done: true
    1042. rename function primitives to macro throughout the codebase
        done: true
      1043. rename constants in VoluntasIds.kt: DEFINES_FUNCTION -> DEFINES_MACRO, DEFINES_BODY_OP -> DEFINES_MACRO_OP, INVOKES_FUNCTION -> INVOKES_MACRO
          done: true
      1044. rename data classes: FunctionDef -> MacroDef, BodyOpTemplate -> MacroBodyOp
          done: true
      1045. rename private state and handlers in VoluntasIntentService: functions -> macros, handleDefinesFunction -> handleDefinesMacro, handleDefinesBodyOp -> handleDefinesMacroOp, handleInvokesFunction -> handleInvokesMacro
          done: true
      1046. rename public API methods: defineFunction -> defineMacro, addBodyOp -> addMacroOp, invokeFunction -> invokeMacro, paramRef stays
          done: true
      1047. update FunctionTest.kt: rename file to MacroTest.kt, update all identifiers and test names
          done: true
      1048. update Runtime.md: replace all occurrences of function/function definition/function invocation with macro equivalents
          done: true
  1146. Add names as a first-class concept in the runtime
    1147. Phase 1: New reserved entities
      1148. Add NAME_TYPE = 11L to VoluntasIds.kt — the type for all name nodes
      1149. Add META_ROOT = 12L to VoluntasIds.kt — root meta intent, child of root intent
      1150. Add NAMES_ROOT = 13L to VoluntasIds.kt — instance of NAME_TYPE, root of path system, child of META_ROOT
      1151. Update FIRST_USER_ENTITY if it would collide (currently safe at 1000)
    1152. Phase 2: New internal state in VoluntasIntentService
      1153. Add nameNodeToPath: MutableMap<Long, String> — name node entity ID to full path string
      1154. Add namesByPath: MutableMap<String, Long> — full path to name node entity ID
      1155. Add nameNodeByReferent: MutableMap<Long, Long> — referent entity ID to its name node entity ID
      1156. Add typeAutoNames: MutableSet<Long> — type entity IDs that auto-name their instances
      1157. Seed nameNodeToPath[NAMES_ROOT] = empty string in constructor so child paths build correctly
    1158. Phase 3: Bootstrap changes in emitBootstrap()
      1159. Emit DEFINES_TYPE for NAME_TYPE (entity 11), with META_ROOT as module entity
      1160. Emit INSTANTIATES STRING_INTENT_TYPE for META_ROOT (entity 12), text='meta', parent=ROOT_INTENT — visible child of root
      1161. Emit INSTANTIATES NAME_TYPE for NAMES_ROOT (entity 13), text='names', parent=META_ROOT
      1162. Emit INSTANTIATES NAME_TYPE for the /meta name node — text='meta', parent=NAMES_ROOT, referent=META_ROOT
    1163. Phase 4: Handle NAME_TYPE in handleInstantiates
      1164. Add NAME_TYPE branch in handleInstantiates: participants = [NAME_TYPE, textLit, parentNameNodeId, referentEntityId]
      1165. Compute path: parentPath = nameNodeToPath[parentNameNodeId], then path = parentPath + '/' + text
      1166. Store: nameNodeToPath[entityId] = path, namesByPath[path] = entityId
      1167. If referentEntityId present: store nameNodeByReferent[referentId] = entityId
      1168. Create meta IntentImpl for the name node (isMeta=true), link as child of parentNameNodeId
    1169. Phase 5: New helper methods
      1170. findOrCreateNameNode(path: String, referentId: Long): Long — splits path on '/', walks/creates name nodes from NAMES_ROOT down
      1171. getEntityByPath(path: String): Long? — looks up namesByPath then nameNodeByReferent
      1172. getNamePath(entityId: Long): String? — looks up nameNodeByReferent in reverse to get the path for any entity
    1173. Phase 6: Update defineType()
      1174. Add autoNameInstances: Boolean = false parameter
      1175. After emitting DEFINES_TYPE, call findOrCreateNameNode(name, typeEntityId) — types always get a name node
      1176. If autoNameInstances=true, emit SETS_FIELD on the type entity: field 'auto-name-instances' = true
      1177. handleDefinesField / handleSetsField will store this in typeAutoNames set during replay
    1178. Phase 7: Update defineMacro()
      1179. After emitting DEFINES_MACRO, call findOrCreateNameNode(name, macroEntityId) — macros always get a name node
      1180. Name is already a full path (e.g. '/standard/add-note') — caller is responsible for passing a rooted path
    1181. Phase 8: Auto-naming instances in handleInstantiates
      1182. After creating entity for a visible-type instantiation, check if typeId in typeAutoNames
      1183. If yes, call findOrCreateNameNode(typePath + '/' + entityId, entityId) to create the instance name node
      1184. typePath is retrieved via getNamePath on the type entity
    1185. Phase 9: Fix lookups that currently use text-matching
      1186. Replace byId.values.find { it.text() == '/standard/interface/command' } with getEntityByPath('/standard/interface/command')
      1187. Audit all similar string-based entity lookups and replace with path-based lookup
    1188. Phase 10: Update GenerateStandardModule.kt
      1189. Pass full rooted paths: defineType('/standard/note', ...) and defineType('/standard/interface/command', ...)
      1190. Pass full rooted path: defineMacro('/standard/add-note', ...)
      1191. Decide autoNameInstances for /standard/note — probably true so note instances get paths like /standard/note/1042
      1192. Update command annotation setFieldValue: 'command-name' = 'note' stays, but keyword now resolves via name path
    1193. Phase 11: Regenerate standard.pb and verify
      1194. Run GenerateStandardModule to regenerate modules/standard.pb with name-aware definitions
      1195. Confirm /standard, /standard/note, /standard/add-note, /standard/interface/command all resolve by path
      1196. Confirm /meta resolves to META_ROOT entity by path
      1197. Run existing MacroTest suite to confirm macro invocation still works
1003. Build Tooling to interact with Runtime
  1005. Command line tool
    1014. basic implementation with explicit commands
        done: true
    1017. allow the commands to be defined in the intent language itself
      1019. make it so the 'do' command is implemented as a function that adds field and sets value
      1063. build standard library module and command interface
          done: true
        1064. write GenerateStandardModule.kt that produces modules/standard.pb
            done: true
          1070. define /standard/note type as a STRING_INTENT_TYPE subtype so its instances are visible non-meta intents with text
              done: true
          1071. define add-note macro with params [textLit, parentId]: body is one INSTANTIATES op for /standard/note with $textLit at participants[2] and $parentId at participants[3]
              done: true
          1072. define /standard/interface/command type with a command-name STRING field
              done: true
          1073. instantiate /standard/interface/command as a child of the add-note macro entity, set command-name field to note
              done: true
        1065. extend handleInstantiates to support visible string-subtype custom types
            done: true
          1074. allow DEFINES_TYPE to declare a parent type via participants[2] (e.g. STRING_INTENT_TYPE) to mark instances as visible
              done: true
          1075. track set of visible types in VoluntasIntentService (initially just STRING_INTENT_TYPE; expanded when DEFINES_TYPE names STRING_INTENT_TYPE as parent)
              done: true
          1076. in handleInstantiates, check if typeId is in visibleTypes and if so create non-meta intent with text from participants[2], parent from participants[3]
              done: true
          1077. update defineType() helper to accept optional parentTypeId and emit it as participants[2] of the DEFINES_TYPE relationship
              done: true
        1066. verify ModuleLoader correctly remaps DEFINES_MACRO and DEFINES_MACRO_OP ops
            done: true
        1067. expose loaded macros and command annotations from VoluntasIntentService
            done: true
          1078. add getMacroByName(name: String) to VoluntasIntentService returning MacroDef and its entity ID
              done: true
          1079. add getCommandAnnotations() returning list of (commandName, macroEntityId) by scanning instances of /standard/interface/command type
              done: true
          1080. track which type entity corresponds to /standard/interface/command by name lookup after module load
              done: true
        1068. add DynamicMacroCommand to CommandExecutor that invokes a named macro
            done: true
          1081. DynamicMacroCommand holds command keyword and macroEntityId; on process() converts text arg to literal ID then calls service.invokeMacro(macroEntityId, listOf(textLitId, focalIntent))
              done: true
          1082. CommandExecutor needs a reference to VoluntasIntentService (not just IntentStreamConsumer) so it can call invokeMacro and literalStore.getOrCreate
              done: true
          1083. add registerCommand(keyword, macroEntityId) on CommandExecutor so dynamic commands can be added after module load
              done: true
        1069. load standard.pb in VoluntasRuntime and register dynamic commands from /standard/interface/command instances
            done: true
          1084. after loadModules() in VoluntasRuntime, call service.getCommandAnnotations() and register a DynamicMacroCommand for each result
              done: true
          1085. standard.pb is always loaded first so its types are available for the main stream and any other modules
              done: true
      1135. this is the first note
  1006. Web interface
    1029. ability for intent ops to define their css rendering styles on the stream
    1037. view on the literal store with reference counts
    1038. ability to see meta-intents
  1018. worker bot
  1020. write standard libraries for common paradigms
    1021. basic task completion
    1022. adding notes
    1023. argumentation
      1024. clarification
      1025. example
      1026. external reference
      1027. noting a crux
  1028. simple command line tools for sending ops to server
  1136. tooling for working on voluntas
    1137. git hook for regenerating text version of plan on commit
        done: true
1004. Write Documentation
  1030. basic readme
      done: true
  1033. explanation of reasoning behind references and literal stores
1124. /standard
1141. Test intent from CLAUDE.md tools
    completed: 1772069325873514654
    done: true
